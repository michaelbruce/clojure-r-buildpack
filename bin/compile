#!/usr/bin/env bash

set -e

BUILD_DIR=$1
CACHE_DIR="$2/vendor"
VENDOR_DIR="$BUILD_DIR/vendor"
LP_DIR=`cd $(dirname $0); cd ..; pwd`
BUILDPACK_DIR="$(dirname $(dirname $0))"
[ -z "${STACK}" ] && STACK="cedar-14"
[ -z "${CRAN_MIRROR}" ] && CRAN_MIRROR="http://cloud.r-project.org"

echo $BUILD_DIR
echo $CACHE_DIR

mkdir -p $CACHE_DIR
mkdir -p $VENDOR_DIR

# Building R binary

S3_BUCKET="heroku-buildpack-r"
BUILD_PACK_VERSION="20160720-0331"
R_VERSION="3.3.1"
R_BINARIES="http://${S3_BUCKET}.s3.amazonaws.com/${STACK}/R-${R_VERSION}-binaries-${BUILD_PACK_VERSION}.tar.gz"

# vendor R into the slug
echo "Vendoring R $R_VERSION for $STACK stack ($BUILD_PACK_VERSION)"
echo "Downloading and unpacking R binaries ($R_BINARIES)"
curl $R_BINARIES -s -o - | tar xzf - -C $BUILD_DIR

mkdir -p /app/.apt
cp -R $VENDOR_DIR/.apt/* /app/.apt

mkdir -p /app/vendor/R
cp -R $VENDOR_DIR/R/* /app/vendor/R

export PATH="/app/vendor/R/bin:/app/.apt/usr/bin:$PATH"
export R_INCLUDE="/app/vendor/R/lib64/R/include"
export LD_LIBRARY_PATH="/app/.apt/usr/lib/libblas:/app/.apt/usr/lib/lapack:/app/.apt/usr/lib/x86_64-linux-gnu:/app/.apt/usr/lib/i386-linux-gnu:/app/.apt/usr/lib:$LD_LIBRARY_PATH"
export LIBRARY_PATH="/app/.apt/usr/lib/x86_64-linux-gnu:/app/.apt/usr/lib/i386-linux-gnu:/app/.apt/usr/lib:$LIBRARY_PATH"
export INCLUDE_PATH="/app/.apt/usr/include:$INCLUDE_PATH"
export CPATH="$INCLUDE_PATH"
export CPPPATH="$INCLUDE_PATH"
export PKG_CONFIG_PATH="/app/.apt/usr/lib/x86_64-linux-gnu/pkgconfig:/app/.apt/usr/lib/i386-linux-gnu/pkgconfig:/app/.apt/usr/lib/pkgconfig:$PKG_CONFIG_PATH"
export LDFLAGS="-L/app/.apt/usr/lib/libblas -L/app/.apt/usr/lib/lapack $LDFLAGS"

# copy over environment
mkdir -p $BUILD_DIR/.profile.d
cp "$BUILDPACK_DIR/bin/r_environment.sh" $BUILD_DIR/.profile.d/r_environment.sh

# Rserve is not accessible at runtime with this one line by itself
# R --no-save -e "install.packages('Rserve', repos='http://cran.us.r-project.org')"

# Building Java binary

BIN_DIR=$(cd $(dirname $0); pwd) # absolute path
. $BIN_DIR/java
. $BIN_DIR/util

# Install JDK
install_java_with_overlay ${BUILD_DIR}

java -version

echo "JAVA_OPTS: $JAVA_OPTS"

# Install boot

get_latest_boot_version() {
  curl -s https://api.github.com/repos/boot-clj/boot/releases \
    | grep 'download_url.*boot\.sh' \
    | head -1 \
    | awk -F '/' '{print $(NF-1)}'
}

BOOT_SH_VERSION=$(get_latest_boot_version)
BOOT_SH_URL="https://github.com/boot-clj/boot/releases/download/${BOOT_SH_VERSION}/boot.sh"
BOOT_SH_CACHE_PATH="$CACHE_DIR/boot"
BOOT_SH_SLUG_PATH="$BUILD_DIR/boot"

if [ ! -r "$BOOT_SH_CACHE_PATH" ]; then
    echo "-----> Installing Boot ${BOOT_SH_VERSION} from github..."
    echo "       Downloading boot.sh"
    echo $BOOT_SH_CACHE_PATH
    echo $BOOT_SH_URL
    curl -L -s -o "$BOOT_SH_CACHE_PATH" "$BOOT_SH_URL"
    chmod a+x "$BOOT_SH_CACHE_PATH"
    echo "       ...done"
else
    echo "-----> Using cached Boot"
fi

# Install TexLive

function build-step (){ echo "-----> $@"; }
function build-warn (){ echo " !     $@"; }
function build-info (){ echo "       $@"; }

TEXLIVE_DOMAIN="https://heroku-buildpack-tex.s3.amazonaws.com"
VERSION=`curl $TEXLIVE_DOMAIN/VERSION -s`
TEXLIVE_URL="$TEXLIVE_DOMAIN/texlive-$VERSION.tar.gz"
TEXLIVE_HOME=$BUILD_DIR/.texlive
TEXLIVE_CACHE=$CACHE_DIR/.texlive
PATH=$TEXLIVE_HOME/bin/x86_64-linux:$PATH
PROFILE_D=$BUILD_DIR/.profile.d/texlive.sh # do we need this? doesn't seem to be used

# Prepare the various paths
mkdir -p $TEXLIVE_HOME
mkdir -p $TEXLIVE_CACHE
mkdir -p `dirname $PROFILE_D`

if [ -f $TEXLIVE_CACHE/VERSION ] && (( $VERSION == `cat $TEXLIVE_CACHE/VERSION` )); then
    # Get TeX Live from the cache if possible
    build-step "Installing TeX Live $VERSION from cache"
    cp -R $TEXLIVE_CACHE/* $TEXLIVE_HOME
else
    # Get TeX Live from S3 if necessary
    if [ -f "$TEXLIVE_CACHE/VERSION" ]; then
        build-step "Upgrading to TeX Live $VERSION"
    else
        build-step "Fetching TeX Live $VERSION"
    fi

    TEXLIVE_URL="ftp://tug.org/historic/systems/texlive/2016/texlive-20160523-bin.tar.xz"
    curl $TEXLIVE_URL -s -o - | tar xzf - -C $TEXLIVE_HOME

    # Make sure the cache is empty
    rm -rf $TEXLIVE_CACHE/*

    # Store a copy of it in the cache so it doesn't have to be fetched again
    cp -R $TEXLIVE_HOME/* $TEXLIVE_CACHE

    # Store the version for later
    echo $VERSION > $TEXLIVE_CACHE/VERSION
fi

# Check for an essential binary to make sure it's installed
if [ ! `which pdflatex` ]; then
    build-warn "TeX Live installation failed"
    exit 1
fi

# Set up the environment for runtimes now that compilation has finished
echo 'export PATH=$HOME/.texlive/bin/x86_64-linux:$PATH' >> $PROFILE_D

# Printing diagnostic information

export PATH="$BUILD_DIR:$CACHE_DIR:$PATH"

echo $PATH

# Compile application as an uberjar

boot build
